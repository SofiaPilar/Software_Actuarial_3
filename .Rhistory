require(graphics)
dnorm(0) == 1/sqrt(2*pi)
dnorm(1) == exp(-1/2)/sqrt(2*pi)
dnorm(1) == 1/sqrt(2*pi*exp(1))
## Using "log = TRUE" for an extended range :
par(mfrow = c(2,1))
plot(function(x) dnorm(x, log = TRUE), -60, 50,
main = "log { Normal density }")
curve(log(dnorm(x)), add = TRUE, col = "red", lwd = 2)
mtext("dnorm(x, log=TRUE)", adj = 0)
mtext("log(dnorm(x))", col = "red", adj = 1)
plot(function(x) pnorm(x, log.p = TRUE), -50, 10,
main = "log { Normal Cumulative }")
curve(log(pnorm(x)), add = TRUE, col = "red", lwd = 2)
mtext("pnorm(x, log=TRUE)", adj = 0)
mtext("log(pnorm(x))", col = "red", adj = 1)
## if you want the so-called 'error function'
erf <- function(x) 2 * pnorm(x * sqrt(2)) - 1
## (see Abramowitz and Stegun 29.2.29)
## and the so-called 'complementary error function'
erfc <- function(x) 2 * pnorm(x * sqrt(2), lower = FALSE)
## and the inverses
erfinv <- function (x) qnorm((1 + x)/2)/sqrt(2)
erfcinv <- function (x) qnorm(x/2, lower = FALSE)/sqrt(2)
help.search("rnorm")
a<-available.packages()
head(row.names(a),3)
nrow(a)
n<signif(row(a),2)
n<-signif(nrow(a), 2)
install.packages("rmarkdown")
install.packages("ggplot2")
install.packages("devtools")
a <- installed.packages()
a <- installed.packages()
view(a)
a <- installed.packages()
view(a)
---
x<-1
x<-1
x<- 1
x<- 2
print(x)
#aqui se esta realizando una asignación
x<- 1
#La asignacion no me premitió realizar el resultado , para ello
print(x)
#al poner mayuscula , que no ha sido definida , me marcará error
print(X)
#La alternativa es solicitar una impresion implicita
x
#La asignacion puede hacerse tambien de textos
msg <- "Hola"
#Al solicitar una imresion , se debera enseñar el mensaje que esta
print(msg)
x<- #expresion incompleta
3
#La alternativa es solicitar una impresion implicita
x
#La asignacion puede hacerse tambien de textos
msg <- "Hola"
#Al solicitar una imresion , se debera enseñar el mensaje que esta
print(msg)
x<- #expresion incompleta
3
#Impresion de un arreglo
x<- 1:20
x
paula<- 3:9
paula
pili <- 99: 43
pili
#El operador permitira generar secuencias númericas
# secuencia de números interos
n= 3: 14.5
n
x
paula
pili
Inf
exp(-Inf)
1/0
print(Inf)
Inf- Inf
x<- c(True , False , True , T , F, F, T) #logical
print(d)
f<- c(1L ,2L, 3L, 4L)   #Integer
print(f)
g<-c(1, 2, 3 , 4) #Numeric
g
e<-c (1+1i, 2+2i , -5+2i , 3.13-2i)  #Complex
e
h<- c("a", "b", "c", "Hola") #Character
h
#Otro posible camino seria la función vector
x <- vector ("numeric", lenght =10)#el vector se creó vacio
x
x <- vector ("numeric", lenght = 10)
x
#Otro posible camino seria la función vector
x <- vector ("numeric", length = 10)
x
yo<-c(1.7 , "a")
ye<- c(TRUE, 2)
yi<-c(false, 2L, 5, 5-4)
yi<-c(false, 2L, 5, 5-4i)
yi<-c(FALSE,5, 5-4i)
YO
yo
sofi <- (0:6)
as.numeric(sofi)
as.character(sofi)
as.complex(sofi)
w<-c ("a" , "b")
as.complex(w)
#Listas
x <- list(1, "a", TRUE , 3+2i , 5L)
x
#Listas
x <- list(1, "a", TRUE , 3+2i , 5L , 1:50)
x
#Todos los elementos de una lista mantienen la clase original
s<- matrix(dinnames = NULL)
s<- matrix(nrow= 2, ncol=2, dinnames = NULL)
<- matrix(nrow= 2, ncol=2, dimnames = NULL)
s <- matrix(nrow= 2, ncol=2, dimnames = NULL)
s
s <- matrix(nrow = 2, ncol=2 ,dimnames = list(1:4))
s <- matrix(nrow = 2, ncol=2 ,dimnames = list(1,2,3,4))
s <- matrix(nrow = 2, ncol=2 ,dimnames = list(1,2)
s
s
l<- matrix(nrow = 2 , ncol = 3)
m dim(m)
l <- matrix(nrow = 2 , ncol = 3)
m
dim(m)
attributes(m)
p <- matrix(nrow = 2, ncol=2 ,dimnames = list)
p
dim(p)
p <- matrix(nrow = 2, ncol=2)
p
dim(p)
p <- matrix(data=1:6 , nrow=2 , ncol=3)
p <- matrix(1:6 ,2,3)
p
#Una manera alternativa de crear una matrix es desde un vector y
m <- 1:10
dim(m) <- c(2,5)
m
#Una manera alternativa de crear una matrix es desde un vector y
m <- 1:10
m
dim(m) <- c(2,5)
m
#Si yo quisiera llenar fila por fila
q <- matrix(date=1:6 , nrow=2, ncol=3 , byrow=true)
q <- matrix(1:6, 2,3 ,T)
q
q <- matrix(data = =1:6 , nrow=2, ncol=3 , byrow=true)
q <- matrix(1:6, 2,3 ,T)
q
q <- matrix(data =1:6 , nrow=2, ncol=3 , byrow=true)
q <- matrix(1:6, 2,3 ,T)
q
q <- matrix(data =1:6 , nrow=2, ncol=3 , byrow=TRUE)
q <- matrix(1:6, 2,3 ,T)
q
#oTRA FORMA DE CREAR UNA MATRIX ES UNIENDO DIFERENTES VECTORES
x<- 1:3
y- 10:12
#CBIND , unir columnas
cbind(x,y)
#RBind los une por filas
rbind(x,y)
#oTRA FORMA DE CREAR UNA MATRIX ES UNIENDO DIFERENTES VECTORES
x <- 1:3
y <- 10:12
#CBIND , unir columnas
cbind(x,y)
#RBind los une por filas
rbind(x,y)
#Los factores
#Los factores
x <- factor (c("Sí" , "Sí" , "No" , "No", "Si"))
x
x <- factor (c("Azul" , "verde", "verde" ,"azul" , "Rojo"))
x
table(x)
unclass(X)
table(x)
unclass(X)
table(x)
unclass(x)
x <- factor (c("Azul" , "verde", "verde" ,"azul" , "Rojo"), levels = c("rojo" , "verde", "amarillo", "naranja", "azul"))
x
table(x)
unclass(x)
table(x)
unclass(x)
x<- c(1,2,NA,10,3)
is.na(x)  #valor faltante detectado
is.nan(x) #Valor no númerico que no es faltante
y<- c(1,2,NA,10,3)
is.nan(y)  #valor faltante detectado
is.na(y) #Valor no númerico que no es faltante
x <- data.frame(foo= 1:4 , bar=c(T, T, F, F))
x
foo bar
is.na(x)  #valor faltante detectado
x <- data.frame(foo= 1:4 , bar=c(T, T, F, F))
x
nrow(x)
ncol(x)
x <- data.frame(foo= 1:4 , bar=c(T, T, F, F))
x
names(x)
m<- matrix(1:4 , nrow=2 , ncol=2)
dimnames(m) <- list(c("a", "b"), c("c", "d"))
m
carros.r
Carros.R
"Carros.R"
mtcars
x <- data.frame(foo= 1:4 , bar=c(T, T, F, F))
x
Carros<- data.frame(mtcars)
Carros
dput(Carros, file="~/GitHub/Software_Actuarial_3/carros.R")
carros2 <- dget(file="~/GitHub/Software_Actuarial_3/carros.R")
dput(Carros, file="~/GitHub/Software_Actuarial_3/carros.R")
carrospili <- dget(file="~/GitHub/Software_Actuarial_3/carros.R")
Carrospili1<- data.frame(mtcars)
Carrospili1
dput(Carrospili1, file="~/GitHub/Software_Actuarial_3/carrospili1.R")
carrospili2 <- dget(file="~/GitHub/Software_Actuarial_3/carrospili1.R")
setwd("-Github/SoftwareActuarial3")
x<- "Software Actuarial III"
y<-data.frame(a=1, b="a")
dump(c("x" , "y"), file="data.R")
rm(x,y)
source("data.R")
#Dump y Source
setwd("-Github/Software_Actuarial_3")
x<- "Software Actuarial III"
y<-data.frame(a=1, b="a")
dump(c("x" , "y"), file="data.R")
rm(x,y)
source("data.R")
#Dump y Source
setwd("-/Github/Software_Actuarial_3")
x<- "Software Actuarial III"
y<-data.frame(a=1, b="a")
dump(c("x" , "y"), file="data.R")
rm(x,y)
source("data.R")
#Dump y Source
setwd("~/Github/Software_Actuarial_3")
x<- "Software Actuarial III"
y<-data.frame(a=1, b="a")
dump(c("x" , "y"), file="data.R")
rm(x,y)
source("data.R")
x
y
con <- url("https://www.fcfm.buap.mx/")
x <- readlines(con , 7)
x
con <- url("https://www.fcfm.buap.mx/")
x <- readLines(con, 7)
x
?writeLines
#conexiones: file , gzfile,
con <- url("https://www.fcfm.buap.mx/")
x <- readLines(con)
x[7]<- "'\t <title>FCFM:Estariamos mejor con x </title> "
writeLines(x, "FCFM.html")
#conexiones: file , gzfile,
con <- url("https://www.fcfm.buap.mx/")
x <- readLines(con)
x[7]<- "'\t <title>FCFM:Estariamos mejor con x </title> "
writeLines(x, "FCFM.html")
#Creamos un vector
x<- c("a", "b" , "c" , "c" , "d" , "e")
x
x[1]
x[2]
#Tambien podemos extraer una secuencia de elementos
x[1:4]
#Es posible extraer los elementos que cumplen una restriccion
x[x>"b"]
#De manera equivalente se puede obtener un vector logico
u<- x --"c"
u
x[u]
x<- c("a", "b" , "c" , "c" , "d" , "e")
x
#extraemos elementos con []
x[1]
x[2]
#Tambien podemos extraer una secuencia de elementos
x[1:4]
#Es posible extraer los elementos que cumplen una restriccion
x[x>"b"]
#De manera equivalente se puede obtener un vector logico
u<- x =="c"
u
x[u]
#creamos una lista
x <- list(foo=1:4 , bar=.6)
x
x[1]
x$foo
x["bar"]
x[("bar")]
x<-matrix(1:6 ,2,3)
x
x<-matrix(1:6 ,2,3)
x
